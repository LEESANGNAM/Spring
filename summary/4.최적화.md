# 최적화 
## 조회최적화 v1
### 무한루프
+ member와 orders의 양방향 연관관계 문제가 생긴다.
![스크린샷 2021-07-27 오후 11 43 47](https://user-images.githubusercontent.com/61412496/127174767-94beb29d-dac0-46e6-b63c-066991d8f332.png)
### 해결법
+ 양방향 연관관계의 한쪽에는 @JsonIgnore를 설정해준다.

### TypeError(지연로딩 문제)
+ Order의 member가 fetch=LAZY(지연로딩)으로 설정되어 member객체가아닌 proxy객체를 처리하지 못하여 생긴다.
![스크린샷 2021-07-27 오후 11 50 25](https://user-images.githubusercontent.com/61412496/127176192-2357083f-ce65-4781-9c60-3bb3a9248323.png)

+ 1. 오더를 가져왔는 데 오더의 멤버의 fetch의 값이 LAZY다  
+ 2. 지연로딩이기때문에 멤버를 디비에서 안가져오고
+ 3. 하이버네이트에서 new member로해서 프록시 멤버를 생성해서 납둔다.
+ 4. member의 값이 필요할때 쿼리를 실행하여 값을 가져와서 채워준다.    

### 해결법
+ build.gradle 에 implementation 'com.fasterxml.jackson.datatype:jackson-datatype-hibernate5' 를 설정
+ 설정 후 Bean으로 등록해준다.
~~~java
@SpringBootApplication
public class JpashopApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpashopApplication.class, args);
    }
    @Bean
    Hibernate5Module hibernate5Module() {
        return new Hibernate5Module();
    }
}
~~~
### LAZY 강제초기화
~~~java 
@GetMapping("/api/v1/simple-orders")
    public List<Order> ordersV1(){
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        for(Order order : all){
            order.getMember().getName(); //lazy 강제초기화
            order.getDelivery().getAddress();
        }
        return all;
    }
~~~
![스크린샷 2021-07-28 오전 12 04 09](https://user-images.githubusercontent.com/61412496/127178451-d9541499-483a-4e79-8940-a7363bf4c78c.png)

+ 양방향 연관관계가 걸린 곳은 꼭! 한곳을 @JsonIgnore 처리를 한다.
+ LAZY 를 EAGER로 바꾸지 말자! 단건으로 조회하면서 나가서 n+1문제가 똑같이터진다.
+ EAGER 로 바꾸면 다른 API에서 필요없을 때에도 무조건 끌고와서 성능 최적화가 힘들어진다.

## 조회 최적화 v2 dto반환
~~~java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {

    private final OrderRepository orderRepository;

    @GetMapping("/api/v2/simple-orders")
    public List<SimpleOrderDto> ordersV2() {
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());

        List<SimpleOrderDto> result = orders.stream()
                .map(o -> new SimpleOrderDto(o))
                .collect(Collectors.toList());

        return result;
    }

    @Data
    static class SimpleOrderDto {
        private Long orderId;
        private String name;
        private LocalDateTime orderDate;
        private OrderStatus orderStatus;
        private Address address;

        public SimpleOrderDto(Order order) {
            orderId = order.getId();
            name = order.getMember().getName();
            orderDate = order.getOrderDate();
            orderStatus = order.getStatus();
            address = order.getDelivery().getAddress();
        }
    }
}
~~~
+ 필요한 정보를 가진 DTO를 생성하여 사용하자.

![스크린샷 2021-07-28 오전 12 11 46](https://user-images.githubusercontent.com/61412496/127179676-02673df5-5373-49d2-a2b8-dc97ea5bf954.png)

### v1과 v2의문제점
#### lazy loding(지연로딩)으로 인한 db 쿼리가 너무많다. 
+ 1. oorder -> sql1번 ->결과 주문수 2개가 조회되서 map 루프를돈다.
+ 2. name = order.getMember().getName();을 할때 영속성 컨택스트에 찾아보고 없으면 쿼리를날린다.
+ 3. address = order.getDelivery().getAddress();도 쿼리를 날린다.
+ 4. 첫번째 SimpleOrderDto 가 생성되었다.
+ 5. 두번째  SimpleOrderDto도 같은방법으로 생성된다.    

### N+1문제
+ N+1 -> 1+회원 N + 배송 N